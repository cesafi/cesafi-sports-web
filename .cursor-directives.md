# CESAFI Sports Website - Cursor AI Development Directives

## ğŸš¨ CRITICAL: MANDATORY FIRST STEP

**BEFORE ANY WORK IN A NEW CHAT SESSION:**

1. **ALWAYS READ THIS DIRECTIVE FILE FIRST** - Use `read_file` tool to read `.cursor-directives.md`
2. **UNDERSTAND THE PROJECT CONTEXT** - Review the architecture, patterns, and current status
3. **FOLLOW ALL DIRECTIVES** - Adhere to the development philosophy, patterns, and quality standards outlined below
4. **REFERENCE THIS FILE** - Use this as your single source of truth for project understanding

**This directive file contains:**

- Complete project architecture understanding
- Development patterns and standards
- Git workflow and branching strategy
- Database structure and relationships
- Security considerations and current issues
- Quality standards and checklists
- All established conventions and best practices

## ğŸ¯ Core Development Philosophy

**QUALITY OVER SPEED**: Every prompt requires deep thinking, thorough analysis, and careful consideration. Sacrifice time and speed for code quality, maintainability, and architectural consistency.

## ğŸ§  Ultra-Thinking Protocol

### Before Any Code Change:

1. **Analyze the full context** - Understand how changes affect the entire system
2. **Prevent redundancy** - Check for existing patterns, utilities, or similar implementations
3. **Consider edge cases** - Think through error scenarios, validation, and data integrity
4. **Evaluate architecture fit** - Ensure changes align with established patterns
5. **Plan for maintainability** - Write code that future developers can easily understand and modify

### Code Quality Checklist:

- [ ] Is this the simplest solution that works?
- [ ] Does this follow existing patterns in the codebase?
- [ ] Are there any potential security vulnerabilities?
- [ ] Is error handling comprehensive?
- [ ] Are types properly defined and validated?
- [ ] Is the code self-documenting?
- [ ] Will this be easy to test?

## ğŸ—ï¸ Project Architecture Understanding

### **Core Architecture Pattern: 5-Layer Service Architecture**

The codebase follows a strict **5-layer architecture** designed for scalability, maintainability, and clear separation of concerns:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    1. COMPONENT LAYER (UI)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Components    â”‚  â”‚   Pages/Routes  â”‚  â”‚   Contexts   â”‚ â”‚
â”‚  â”‚   (UI/UX)       â”‚  â”‚   (App Router)  â”‚  â”‚  (Providers) â”‚ â”‚
â”‚  â”‚ Thin & Focused  â”‚  â”‚   Next.js 15    â”‚  â”‚  React Query â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    2. HOOKS LAYER (src/hooks/)             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Query Key       â”‚  â”‚ Data Fetching   â”‚  â”‚ Cache        â”‚ â”‚
â”‚  â”‚ Factories       â”‚  â”‚ (useQuery)      â”‚  â”‚ Management   â”‚ â”‚
â”‚  â”‚ Cache Inval.    â”‚  â”‚ Mutations       â”‚  â”‚ & Transform  â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   3. ACTIONS LAYER (src/actions/)          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Server Actions  â”‚  â”‚ 'use server'    â”‚  â”‚ Next.js      â”‚ â”‚
â”‚  â”‚ (Next.js 15)    â”‚  â”‚ Directive       â”‚  â”‚ Integration  â”‚ â”‚
â”‚  â”‚ revalidatePath  â”‚  â”‚ API Boundary    â”‚  â”‚ Cache Inval. â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   4. SERVICES LAYER (src/services/)        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ BaseService     â”‚  â”‚ Business Logic  â”‚  â”‚ CRUD Ops     â”‚ â”‚
â”‚  â”‚ Pattern         â”‚  â”‚ & Validation    â”‚  â”‚ Pagination   â”‚ â”‚
â”‚  â”‚ Error Handling  â”‚  â”‚ Filtering       â”‚  â”‚ Searching    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    5. DATABASE LAYER                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Supabase        â”‚  â”‚ Auto-generated  â”‚  â”‚ PostgreSQL   â”‚ â”‚
â”‚  â”‚ PostgreSQL      â”‚  â”‚ TypeScript      â”‚  â”‚ + Auth       â”‚ â”‚
â”‚  â”‚ Real-time       â”‚  â”‚ Types           â”‚  â”‚ + Storage    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **Detailed Layer Responsibilities:**

#### **1. Component Layer (UI)**

- **React components** in `src/app/` and `src/components/`
- **Thin and focused** on presentation logic only
- **No business logic** - purely UI concerns
- **User interactions** and interface rendering

#### **2. Hooks Layer (src/hooks/)**

- **Data access layer** for components
- **Query key factories** for consistent cache management
- **TanStack Query integration** (useQuery, useMutation)
- **Loading/error state handling**
- **Cache invalidation** and data transformation
- **Component-ready data** preparation

#### **3. Actions Layer (src/actions/)**

- **Server actions** with `'use server'` directive
- **Bridge** between client hooks and server services
- **Next.js integration** (revalidatePath, cache invalidation)
- **Clean API boundary** between client and server
- **Server-side execution** for security and performance

#### **4. Services Layer (src/services/)**

- **Business logic layer** with database operations
- **BaseService pattern** for consistency
- **Universal client management** (server/browser)
- **Standardized error handling**
- **Advanced features**: pagination, filtering, searching, sorting
- **ServiceResponse<T>** standardized return types

#### **5. Database Layer**

- **Supabase PostgreSQL** with auto-generated TypeScript types
- **Type safety** from database to UI
- **Real-time capabilities** and authentication
- **Row-level security** and data integrity

### **Data Flow Architecture:**

#### **Read Operations:**

```
Component â†’ Hook â†’ Service â†’ Supabase â†’ Service â†’ Hook â†’ Component
```

#### **Write Operations:**

```
Component â†’ Hook â†’ Action â†’ Service â†’ Supabase â†’ Service â†’ Action â†’ Hook â†’ Component
(with cache invalidation)
```

**Key Principle**: Each layer has specific responsibilities and **never skips layers**.

## ğŸ“ File Organization Logic (Feature-Based Architecture)

### **Feature-Based Organization Pattern**

The codebase follows a **feature-based organization** where each sports entity has corresponding files across all layers:

```
For each entity (schools, teams, games, matches, etc.):
â”œâ”€â”€ actions/entity.ts      # Server actions
â”œâ”€â”€ services/entity.ts     # Business logic
â”œâ”€â”€ hooks/use-entity.ts    # React Query hooks
â”œâ”€â”€ lib/types/entity.ts    # TypeScript types
â””â”€â”€ lib/validations/entity.ts # Zod schemas
```

**Benefits:**

- **Easy feature discovery** - all related code in predictable locations
- **Complete data flow understanding** - see entire entity lifecycle
- **Consistent patterns** - same structure for all entities
- **Scalable architecture** - add new entities by following established pattern

### **Folder Structure & Responsibilities**

#### **`src/app/` - Next.js App Router**

- **`(landing)/`** - Route groups for landing pages
- **`(auth)/`** - Authentication routes
- **`layout.tsx`** - Root layout with providers
- **`metadata.ts`** - SEO and metadata configuration
- **`globals.css`** - Global styles and Tailwind imports

#### **`src/components/` - React Components**

- **`ui/`** - Shadcn/UI base components (reusable, unstyled)
- **`contexts/`** - React Context providers (QueryProvider, ThemeProvider)
- **Root level** - Feature-specific components

#### **`src/lib/` - Utility Libraries**

- **`types/`** - TypeScript type definitions for each entity
- **`validations/`** - Zod validation schemas
- **`supabase/`** - Database client configuration (server/browser)
- **`utils.ts`** - Helper utilities and common functions

#### **`src/services/` - Data Access Layer**

- **`base.ts`** - Abstract BaseService class with common CRUD operations
- **Entity services** - Extend BaseService for specific entities
- **Pattern**: `EntityService extends BaseService`

#### **`src/actions/` - Next.js Server Actions**

- **Pattern**: One file per entity with CRUD operations
- **Validation**: Zod schemas at action level
- **Error Handling**: Consistent error responses

#### **`src/hooks/` - Custom React Hooks**

- **Pattern**: React Query hooks for data fetching
- **Query Keys**: Structured key patterns for cache management
- **Mutations**: Optimistic updates and cache invalidation

## ğŸ§  State Management Philosophy

### **Server-State-First Approach**

The application follows a **server-state-first** philosophy:

#### **Local Component State (Minimal)**

- **UI concerns only** - form inputs, modal states, loading indicators
- **Temporary state** - user interactions, component visibility
- **No business data** - all business logic in server state

#### **Server State (TanStack Query)**

- **All business data** managed through React Query
- **Automatic caching** and background updates
- **Optimistic updates** for better UX
- **Cache invalidation** after mutations
- **Real-time capabilities** via Supabase subscriptions

#### **State Flow Pattern**

```
User Action â†’ Component State (UI) â†’ Hook (Query) â†’ Action â†’ Service â†’ Database
                â†“
            Cache Update â†’ Component Re-render
```

**Benefits:**

- **Consistent data** across components
- **Automatic synchronization** with server
- **Optimistic updates** for responsive UX
- **Background refetching** for fresh data
- **Error handling** and retry logic

## ğŸ”§ Development Patterns & Standards

### **BaseService Pattern (Critical Architecture Component)**

The `BaseService` class (`src/services/base.ts`) is the **foundation** of the entire service layer:

#### **Client Management**

```typescript
protected static async getClient() {
  const isServer = typeof window === 'undefined';

  if (isServer) {
    const { createClient: createServerClient } = await import('@/lib/supabase/server');
    return createServerClient();
  } else {
    const { createClient: createBrowserClient } = await import('@/lib/supabase/client');
    return createBrowserClient();
  }
}
```

- **Intelligent client instantiation** - automatically detects server vs client environment
- **Universal compatibility** - same service code works in both environments
- **Environment-specific optimization** - uses appropriate Supabase client

#### **Standardized Error Handling**

```typescript
protected static formatError<T>(error: unknown, message: string): ServiceResponse<T> {
  return {
    success: false,
    error: message
  };
}
```

- **Consistent error format** across all services
- **User-friendly error messages**
- **Standardized ServiceResponse<T>** return type

#### **Generic Pagination System**

```typescript
protected static async getPaginatedData<T, TableName extends keyof Database['public']['Tables']>(
  tableName: TableName,
  options: PaginationOptions,
  selectQuery: string = '*'
): Promise<ServiceResponse<PaginatedResponse<T>>>
```

**Advanced Features:**

- **Filtering support**: exact matches, ranges, array filters
- **Full-text search** across specified fields
- **Sorting** by any field (ascending/descending)
- **Automatic count calculation** for pagination metadata
- **Type-safe** with database schema integration

#### **Service Layer Pattern**

```typescript
// BaseService provides common functionality
export abstract class BaseService {
  protected static async getClient(); // Universal client
  protected static formatError<T>(); // Standardized error handling
  protected static async getPaginatedData<T>(); // Generic pagination
}

// Entity services extend BaseService
export class EntityService extends BaseService {
  static async getPaginated(); // Get with filters/pagination
  static async getAll(); // Get all records
  static async getById(); // Single record retrieval
  static async insert(); // Create new record
  static async updateById(); // Update existing record
  static async deleteById(); // Remove record
}
```

### **Hook Pattern (Query Management Architecture)**

#### **Query Key Factory Pattern**

```typescript
// Query keys for cache management
export const entityKeys = {
  all: ['entities'] as const,
  paginated: (options) => [...entityKeys.all, 'paginated', options] as const,
  details: (id) => [...entityKeys.all, id] as const,
  byStage: (stageId) => [...entityKeys.all, 'stage', stageId] as const
};
```

**Query Key Benefits:**

- **Consistent cache keys** across the application
- **Precise cache invalidation** (all entities, paginated results, specific details)
- **Prevents cache key conflicts**
- **Predictable key structures** for debugging
- **Hierarchical invalidation** (invalidate all schools vs specific school)

#### **React Query Hook Pattern**

```typescript
// Data fetching hooks
export function usePaginatedEntities(options, queryOptions?) {
  return useQuery({
    queryKey: entityKeys.paginated(options),
    queryFn: () => getPaginatedEntities(options),
    ...queryOptions
  });
}

export function useEntity(id, queryOptions?) {
  return useQuery({
    queryKey: entityKeys.details(id),
    queryFn: () => getEntityById(id),
    enabled: !!id,
    ...queryOptions
  });
}

// Mutation hooks with cache invalidation
export function useCreateEntity() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createEntity,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: entityKeys.all });
    }
  });
}

export function useUpdateEntity() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: updateEntity,
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: entityKeys.all });
      queryClient.invalidateQueries({ queryKey: entityKeys.details(data.id) });
    }
  });
}

export function useDeleteEntity() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: deleteEntity,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: entityKeys.all });
    }
  });
}
```

**Hook Responsibilities:**

- **Data access layer** for components
- **Loading/error state management**
- **Cache invalidation** after mutations
- **Optimistic updates** where appropriate
- **Component-ready data** transformation

### **Validation Pattern**

```typescript
// Zod schemas for each entity
export const EntityInsertSchema = z.object({
  // Field validations with custom messages
});

export const EntityUpdateSchema = EntityInsertSchema.partial().extend({
  id: z.string().uuid()
});
```

### **Type Safety Architecture (End-to-End)**

The system maintains **type safety from database to UI** through multiple layers:

#### **1. Database Types (Auto-generated)**

```typescript
// database.types.ts - Auto-generated from Supabase
export type Database = {
  public: {
    Tables: {
      schools: {
        Row: { id: string; name: string /* ... */ };
        Insert: { name: string /* ... */ };
        Update: { name?: string /* ... */ };
      };
    };
  };
};
```

#### **2. Service Types (Entity-specific)**

```typescript
// src/lib/types/entities.ts
export interface Entity {
  id: string;
  created_at: string;
  updated_at: string;
  // ... other fields
}

export interface EntityInsert extends Omit<Entity, 'id' | 'created_at' | 'updated_at'> {}
export interface EntityUpdate extends Partial<EntityInsert> {
  id: string;
}

export interface EntityPaginationOptions extends PaginationOptions {
  // Entity-specific filters
}
```

#### **3. Base Type System**

```typescript
// src/lib/types/base.ts
export interface PaginatedResponse<T> {
  data: T[];
  totalCount: number;
  pageCount: number;
  currentPage: number;
}

export type ServiceResponse<T> =
  | { success: true; data: T; id?: string }
  | { success: false; error: string; validationErrors?: Record<string, string[]> };

export interface PaginationOptions<TFilters = Record<string, FilterValue>> {
  page: number;
  pageSize: number;
  searchQuery?: string;
  searchableFields?: string[];
  filters?: TFilters;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}
```

#### **4. Validation Schemas (Runtime Type Safety)**

```typescript
// src/lib/validations/entities.ts
export const EntityInsertSchema = z.object({
  name: z.string().min(1, { message: 'Name is required.' })
  // ... other validations
});

export const EntityUpdateSchema = EntityInsertSchema.partial().extend({
  id: z.string().uuid()
});
```

**Type Safety Benefits:**

- **Compile-time safety** with TypeScript
- **Runtime validation** with Zod schemas
- **Database schema sync** with auto-generated types
- **Consistent interfaces** across all layers
- **IDE support** with autocomplete and error detection

## ğŸš€ Git Workflow & Branching Strategy

### **Current Branch Status:**

- **Active Branch**: `dev` (staging/integration)
- **Production Branch**: `main` (production-ready)
- **Feature Branch**: `feat/facebook-api-implementation` (in progress)

### **Branch Naming Convention:**

- **`feat/<description>`** - New features (e.g., `feat/live-scoreboard`)
- **`fix/<description>`** - Bug fixes (e.g., `fix/login-issue`)
- **`docs/<description>`** - Documentation updates
- **`refactor/<description>`** - Code improvements without new features
- **`chore/<description>`** - Maintenance tasks, dependencies

### **Commit Message Standards:**

```
type(scope): brief description

Detailed explanation of changes, if needed.

- Bullet points for specific changes
- Reference issues: Fixes #123
```

**Types**: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

### **Workflow:**

1. Create feature branch from `main`
2. Work on changes with frequent commits
3. Open PR against `main`
4. Code review and approval required
5. Merge to `main` â†’ Vercel auto-deployment

## ğŸ—„ï¸ Database Architecture (Complete Schema Understanding)

### **Core Entities & Relationships:**

```
schools (17 institutions) - UUID primary key
â”œâ”€â”€ schools_teams (teams per school per season)
â”‚   â””â”€â”€ match_participants (team participation in matches)
â”‚       â””â”€â”€ matches (game events with scheduling)
â”‚           â””â”€â”€ games (individual games within matches)
â”‚               â””â”€â”€ game_scores (scoring data per game)

sports (basketball, volleyball, etc.) - numeric ID
â”œâ”€â”€ sports_categories (division + level combinations)
â”‚   â””â”€â”€ sports_seasons_stages (competition stages)
â”‚       â””â”€â”€ matches (scheduled games)

articles (news & content) - JSON content field
â”œâ”€â”€ authored_by (volunteers) - UUID foreign key

volunteers (staff management) - UUID primary key
â”œâ”€â”€ departments (organizational structure) - numeric ID
â””â”€â”€ seasons (academic years) - numeric ID
```

### **Complete Entity Details:**

#### **Core Sports Entities:**

- **`schools`** - 17 educational institutions (UUID, abbreviation, logo_url, is_active)
- **`sports`** - Sport categories (numeric ID, name)
- **`sports_categories`** - Division/level combinations (men/women/mixed, elementary/high_school/college)
- **`seasons`** - Academic years (start_at, end_at)
- **`sports_seasons_stages`** - Competition stages (group_stage, playins, playoffs, finals)

#### **Team & Match Entities:**

- **`schools_teams`** - Teams per school per season (links schools to sports_categories)
- **`matches`** - Game events (scheduled_at, start_at, end_at, venue, best_of, status)
- **`match_participants`** - Teams participating in matches (team_id, match_score)
- **`games`** - Individual games within matches (game_number, duration)
- **`game_scores`** - Scoring data (score, game_id, match_participant_id)

#### **Content & Management Entities:**

- **`articles`** - News content (authored_by, content as JSON, status workflow)
- **`volunteers`** - Staff management (department_id, season_id, full_name)
- **`departments`** - Organizational structure (name)

### **Enum System:**

```typescript
// Article workflow
article_status: 'review' | 'published' | 'revise' | 'cancelled' | 'approved';

// Competition stages
competition_stage: 'group_stage' | 'playins' | 'playoffs' | 'finals';

// Match status
match_status: 'upcoming' | 'ongoing' | 'finished' | 'cancelled';

// Sport divisions
sport_divisions: 'men' | 'women' | 'mixed';

// Sport levels
sport_levels: 'elementary' | 'high_school' | 'college';

// User roles
user_roles: 'admin' | 'head_writer' | 'league_operator' | 'writer';
```

### **Key Database Features:**

- **Row-Level Security (RLS)** - Database-level permissions
- **Real-time subscriptions** - Live updates via Supabase
- **Mixed ID system** - UUID for schools/teams, numeric for matches/games
- **Audit fields** - `created_at`, `updated_at` timestamps
- **Soft deletes** - `is_active` flags where appropriate
- **JSON content** - Articles use JSON for rich content
- **Foreign key constraints** - Proper referential integrity

## ğŸ› ï¸ Implementation Guidelines (Step-by-Step Process)

### **Adding New Entities (Complete Process)**

When adding a new entity to the system, follow this exact sequence:

#### **1. Database Layer**

```bash
# Add table to Supabase dashboard
# Regenerate types
supabase gen types typescript --project-id YOUR_PROJECT_ID > database.types.ts
```

#### **2. Types Layer (`src/lib/types/entity.ts`)**

```typescript
import { Database } from '../../../database.types';
import { FilterValue, PaginationOptions } from './base';

// Direct database type mapping
export type Entity = Database['public']['Tables']['entities']['Row'];
export type EntityInsert = Database['public']['Tables']['entities']['Insert'];
export type EntityUpdate = Database['public']['Tables']['entities']['Update'];

// Custom interfaces for complex relationships
export interface EntityWithDetails extends Entity {
  related_entity: {
    id: string;
    name: string;
  };
}

// Search filters
export interface EntitySearchFilters {
  name?: string;
  status?: string;
  created_at?: {
    gte?: string;
    lte?: string;
  };
}

// Pagination options
export type EntityPaginationOptions = PaginationOptions<
  EntitySearchFilters & Record<string, FilterValue>
>;
```

#### **3. Validation Layer (`src/lib/validations/entity.ts`)**

```typescript
import { z } from 'zod';

export const createEntitySchema = z
  .object({
    name: z.string().min(1, { message: 'Name is required.' }),
    description: z.string().optional(),
    status: z.enum(['active', 'inactive']).default('active')
  })
  .refine(
    (data) => {
      // Business rule validation
      return data.name.length >= 2;
    },
    { message: 'Name must be at least 2 characters.', path: ['name'] }
  );

export const updateEntitySchema = createEntitySchema.partial().extend({
  id: z.string().uuid({ message: 'ID must be a valid UUID.' })
});
```

#### **4. Services Layer (`src/services/entity.ts`)**

```typescript
import {
  PaginatedResponse,
  PaginationOptions,
  ServiceResponse,
  FilterValue
} from '@/lib/types/base';
import { BaseService } from './base';
import { Entity, EntityInsert, EntityUpdate } from '@/lib/types/entity';

const TABLE_NAME = 'entities';

export class EntityService extends BaseService {
  static async getPaginated(
    options: PaginationOptions<Record<string, FilterValue>>,
    selectQuery: string = '*'
  ): Promise<ServiceResponse<PaginatedResponse<Entity>>> {
    try {
      const searchableFields = ['name', 'description'];
      const optionsWithSearchableFields = {
        ...options,
        searchableFields
      };

      const result = await this.getPaginatedData<Entity, typeof TABLE_NAME>(
        TABLE_NAME,
        optionsWithSearchableFields,
        selectQuery
      );

      return result;
    } catch (err) {
      return this.formatError(err, `Failed to retrieve paginated ${TABLE_NAME}.`);
    }
  }

  static async getAll(): Promise<ServiceResponse<Entity[]>> {
    try {
      const supabase = await this.getClient();
      const { data, error } = await supabase.from(TABLE_NAME).select();

      if (error) throw error;
      return { success: true, data };
    } catch (err) {
      return this.formatError(err, `Failed to fetch all ${TABLE_NAME}.`);
    }
  }

  static async getById(id: string): Promise<ServiceResponse<Entity>> {
    try {
      const supabase = await this.getClient();
      const { data, error } = await supabase.from(TABLE_NAME).select().eq('id', id).single();

      if (error) throw error;
      return { success: true, data };
    } catch (err) {
      return this.formatError(err, `Failed to fetch ${TABLE_NAME} entity.`);
    }
  }

  static async insert(data: EntityInsert): Promise<ServiceResponse<undefined>> {
    try {
      const supabase = await this.getClient();
      const { error } = await supabase.from(TABLE_NAME).insert(data);

      if (error) throw error;
      return { success: true, data: undefined };
    } catch (err) {
      return this.formatError(err, `Failed to insert new ${TABLE_NAME} entity.`);
    }
  }

  static async updateById(data: EntityUpdate): Promise<ServiceResponse<undefined>> {
    try {
      if (!data.id) {
        return { success: false, error: 'Entity ID is required to update.' };
      }

      const supabase = await this.getClient();
      const { error } = await supabase.from(TABLE_NAME).update(data).eq('id', data.id);

      if (error) throw error;
      return { success: true, data: undefined };
    } catch (err) {
      return this.formatError(err, `Failed to update ${TABLE_NAME} entity.`);
    }
  }

  static async deleteById(id: string): Promise<ServiceResponse<undefined>> {
    try {
      if (!id) {
        return { success: false, error: 'Entity ID is required to delete.' };
      }

      const supabase = await this.getClient();
      const { error } = await supabase.from(TABLE_NAME).delete().eq('id', id);

      if (error) throw error;
      return { success: true, data: undefined };
    } catch (err) {
      return this.formatError(err, `Failed to delete ${TABLE_NAME} entity.`);
    }
  }
}
```

#### **5. Actions Layer (`src/actions/entity.ts`)**

```typescript
'use server';

import { PaginationOptions, FilterValue } from '@/lib/types/base';
import { EntityInsert, EntityUpdate } from '@/lib/types/entity';
import { EntityService } from '@/services/entity';
import { revalidatePath } from 'next/cache';

export async function getPaginatedEntities(
  options: PaginationOptions<Record<string, FilterValue>>
) {
  try {
    const result = await EntityService.getPaginated(options);

    if (!result.success || !result.data) {
      return {
        success: false,
        error: result.success === false ? result.error : 'No data returned from service'
      };
    }

    return {
      success: true,
      data: {
        data: result.data.data,
        totalCount: result.data.totalCount,
        pageCount: result.data.pageCount,
        currentPage: result.data.currentPage
      }
    };
  } catch {
    return {
      success: false,
      error: 'Unknown error occurred'
    };
  }
}

export async function getAllEntities() {
  return await EntityService.getAll();
}

export async function getEntityById(id: string) {
  return await EntityService.getById(id);
}

export async function createEntity(data: EntityInsert) {
  const result = await EntityService.insert(data);

  if (result.success) {
    revalidatePath('/admin/entities');
  }

  return result;
}

export async function updateEntityById(data: EntityUpdate) {
  const result = await EntityService.updateById(data);

  if (result.success) {
    revalidatePath('/admin/entities');
  }

  return result;
}

export async function deleteEntityById(id: string) {
  const result = await EntityService.deleteById(id);

  if (result.success) {
    revalidatePath('/admin/entities');
  }

  return result;
}
```

#### **6. Hooks Layer (`src/hooks/use-entity.ts`)**

```typescript
import {
  useQuery,
  useMutation,
  useQueryClient,
  UseQueryOptions,
  UseMutationOptions
} from '@tanstack/react-query';

import {
  getPaginatedEntities,
  getAllEntities,
  getEntityById,
  createEntity,
  updateEntityById,
  deleteEntityById
} from '@/actions/entity';

import { EntityInsert, EntityUpdate, EntityPaginationOptions, Entity } from '@/lib/types/entity';
import { ServiceResponse, FilterValue, PaginationOptions } from '@/lib/types/base';

// Query key factory
export const entityKeys = {
  all: ['entities'] as const,
  paginated: (options: EntityPaginationOptions) =>
    [...entityKeys.all, 'paginated', options] as const,
  details: (id: string) => [...entityKeys.all, id] as const,
  byStatus: (status: string) => [...entityKeys.all, 'status', status] as const
};

// Data fetching hooks
export function usePaginatedEntities(
  options: EntityPaginationOptions,
  queryOptions?: UseQueryOptions<
    {
      success: boolean;
      error?: string;
      data?: { data: Entity[]; totalCount: number; pageCount: number; currentPage: number };
    },
    Error,
    { data: Entity[]; totalCount: number; pageCount: number; currentPage: number }
  >
) {
  return useQuery({
    queryKey: entityKeys.paginated(options),
    queryFn: () => getPaginatedEntities(options),
    select: (data) => {
      if (!data.success || !data.data) {
        throw new Error(data.error || 'Failed to fetch paginated entities.');
      }
      return data.data;
    },
    ...queryOptions
  });
}

export function useAllEntities(
  queryOptions?: UseQueryOptions<ServiceResponse<Entity[]>, Error, Entity[]>
) {
  return useQuery({
    queryKey: entityKeys.all,
    queryFn: getAllEntities,
    select: (data) => {
      if (!data.success || !data.data) {
        throw new Error(data.success === false ? data.error : 'Failed to fetch all entities.');
      }
      return data.data;
    },
    ...queryOptions
  });
}

export function useEntityById(
  id: string,
  queryOptions?: UseQueryOptions<ServiceResponse<Entity>, Error, Entity>
) {
  return useQuery({
    queryKey: entityKeys.details(id),
    queryFn: () => getEntityById(id),
    enabled: !!id,
    select: (data) => {
      if (!data.success || !data.data) {
        throw new Error(data.success === false ? data.error : `Entity with ID ${id} not found.`);
      }
      return data.data;
    },
    ...queryOptions
  });
}

// Mutation hooks with cache invalidation
export function useCreateEntity(
  mutationOptions?: UseMutationOptions<ServiceResponse<undefined>, Error, EntityInsert>
) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: createEntity,
    onSuccess: (result, variables, context) => {
      if (result.success) {
        queryClient.invalidateQueries({ queryKey: entityKeys.all });
      }
      mutationOptions?.onSuccess?.(result, variables, context);
    },
    onError: (error, variables, context) => {
      console.error('Failed to create entity:', error);
      mutationOptions?.onError?.(error, variables, context);
    },
    ...mutationOptions
  });
}

export function useUpdateEntity(
  mutationOptions?: UseMutationOptions<ServiceResponse<undefined>, Error, EntityUpdate>
) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: updateEntityById,
    onSuccess: (result, variables, context) => {
      if (result.success) {
        queryClient.invalidateQueries({ queryKey: entityKeys.all });
        if (variables.id) {
          queryClient.invalidateQueries({ queryKey: entityKeys.details(variables.id) });
        }
      }
      mutationOptions?.onSuccess?.(result, variables, context);
    },
    onError: (error, variables, context) => {
      console.error('Failed to update entity:', error);
      mutationOptions?.onError?.(error, variables, context);
    },
    ...mutationOptions
  });
}

export function useDeleteEntity(
  mutationOptions?: UseMutationOptions<ServiceResponse<undefined>, Error, string>
) {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: deleteEntityById,
    onSuccess: (result, id, context) => {
      if (result.success) {
        queryClient.invalidateQueries({ queryKey: entityKeys.all });
        queryClient.invalidateQueries({ queryKey: entityKeys.details(id) });
        // CRITICAL: Invalidate related entities that depend on this entity
        // Example: queryClient.invalidateQueries({ queryKey: ['related-entities'] });
      }
      mutationOptions?.onSuccess?.(result, id, context);
    },
    onError: (error, id, context) => {
      console.error('Failed to delete entity:', error);
      mutationOptions?.onError?.(error, id, context);
    },
    ...mutationOptions
  });
}
```

### **Critical Implementation Rules:**

1. **Never skip layers** - Changes must flow through all 5 layers
2. **Maintain type safety** - Update types and validation schemas
3. **Handle relationships** - Consider impact on related entities
4. **Cache invalidation** - Update invalidation strategies for related data
5. **Error handling** - Use consistent ServiceResponse<T> pattern
6. **Business rules** - Enforce in validation layer with Zod schemas

## ğŸ” Security & Authentication Architecture

### **Supabase Auth Integration**

- **Built-in authentication system** with email/password and social providers
- **Session management** across server and client environments
- **Automatic token refresh** and session persistence
- **Secure cookie handling** for server-side authentication

### **Role-Based Access Control**

```typescript
// Role hierarchy
const ROLES = {
  admin: ['admin', 'league_operator', 'volunteer'],
  league_operator: ['league_operator', 'volunteer'],
  volunteer: ['volunteer']
};
```

**Roles:**

- **`admin`** - Full system access, user management
- **`league_operator`** - Sports management, team operations
- **`volunteer`** - Content creation, basic operations

### **Authorization Implementation**

```typescript
// Service-level permission checks
const authResult = await AuthService.checkAuth(['admin', 'league_operator']);

if (!authResult.authenticated) {
  return { success: false, error: 'Authentication failed.' };
}

if (!authResult.authorized) {
  return { success: false, error: 'Insufficient permissions.' };
}
```

### **Row-Level Security (RLS)**

- **Database-level permission enforcement** via Supabase RLS policies
- **Automatic filtering** based on user roles and permissions
- **Secure data access** without exposing unauthorized data
- **Policy-based access control** for fine-grained permissions

### **Middleware Integration**

- **Session management** across server and client
- **Route protection** for authenticated areas
- **Automatic session refresh** and token validation
- **Security headers** (currently disabled - needs fixing)

### **Current Security Status:**

- **Middleware**: DISABLED (commented out in `src/middleware.ts`)
- **Authentication**: Functional via Supabase Auth
- **Authorization**: Service-level checks implemented
- **RLS**: Database policies in place

### **Security Headers (Currently Disabled):**

```typescript
// Security headers in middleware (commented out)
'X-Content-Type-Options': 'nosniff'
'X-Frame-Options': 'DENY'
'X-XSS-Protection': '1; mode=block'
'Referrer-Policy': 'strict-origin-when-cross-origin'
'Permissions-Policy': 'camera=(), microphone=(), geolocation=(), interest-cohort=()'
```

## âš™ï¸ Environment & Configuration

### **Environment-Based Configuration**

The system uses environment-based configuration for different deployment stages:

#### **Required Environment Variables**

```bash
# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key

# Cloudinary Configuration (for image management)
NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME=your_cloudinary_cloud_name

# Site Configuration
NEXT_PUBLIC_SITE_URL=your_site_url
```

#### **Configuration Files**

- **`next.config.ts`** - Next.js configuration with image optimization for Supabase storage
- **`tsconfig.json`** - TypeScript strict mode configuration
- **`tailwind.config.js`** - Tailwind CSS configuration
- **`eslint.config.mjs`** - ESLint configuration for code quality
- **`jest.config.ts`** - Jest testing configuration

#### **Environment-Specific Settings**

- **Development**: Turbopack for fast builds, hot reloading
- **Production**: Optimized builds, security headers, performance optimizations
- **Testing**: Jest with jsdom environment for React component testing

## ğŸ§ª Testing Strategy

### **Current Testing Setup:**

- **Framework**: Jest + React Testing Library
- **Configuration**: Next.js optimized setup
- **Status**: No test files exist yet (setup ready)

### **Testing Philosophy:**

- **Unit Tests**: Individual functions, utilities, components
- **Integration Tests**: Component + hook interactions
- **Focus Areas**: Services, validation schemas, custom hooks

## ğŸ¨ UI/UX Standards

### **Design System:**

- **Component Library**: Shadcn/UI (Radix UI primitives)
- **Styling**: Tailwind CSS 4.0
- **Icons**: Lucide React
- **Animations**: Framer Motion
- **Theme**: Light/Dark mode support

### **Component Standards:**

- **Composition over inheritance**
- **Accessibility first** (ARIA labels, keyboard navigation)
- **Responsive design** (mobile-first approach)
- **Consistent spacing** (Tailwind spacing scale)

## ğŸ“¦ Key Dependencies & Versions

### **Core Framework:**

- **Next.js**: 15.4.2 (React 19.1.0)
- **TypeScript**: 5+ (strict mode)
- **Supabase**: 2.52.0 (PostgreSQL + Auth)

### **State Management:**

- **TanStack React Query**: 5.83.0 (data fetching/caching)
- **React Context**: Theme and query providers

### **UI & Styling:**

- **Tailwind CSS**: 4.0
- **Shadcn/UI**: Latest (Radix UI components)
- **Framer Motion**: 12.23.6 (animations)

### **Validation & Types:**

- **Zod**: 4.0.5 (schema validation)
- **TypeScript**: 5+ (type safety)

### **Media & Assets:**

- **Cloudinary**: 6.16.0 (image management)
- **next-cloudinary**: Image optimization

## ğŸš¨ Current Issues & Technical Debt

### **Critical Issues:**

1. **Middleware Disabled** - Security headers commented out
2. **Landing Page** - Currently shows only "test"
3. **No Tests** - Testing framework ready but no tests written

### **Technical Debt:**

1. **Error Handling** - Some services use generic error catching
2. **Type Safety** - Some `any` types in base service
3. **Documentation** - Limited inline code documentation

## ğŸ¯ Development Priorities

### **Immediate (High Priority):**

1. Fix middleware security issues
2. Implement comprehensive testing
3. Complete landing page development
4. Set up proper CI/CD pipeline

### **Short Term:**

1. Live score updates functionality
2. User authentication flows
3. Mobile responsiveness improvements
4. Performance optimizations

### **Long Term:**

1. Advanced analytics and statistics
2. Mobile app (React Native/PWA)
3. Real-time notifications
4. Advanced content management

## ğŸ” Code Quality Standards

### **Readability & Maintainability:**

- **Self-documenting code** - Clear variable/function names
- **Consistent formatting** - Prettier + ESLint
- **Modular design** - Single responsibility principle
- **Type safety** - Comprehensive TypeScript usage

### **Performance Considerations:**

- **React Query caching** - Smart cache invalidation
- **Image optimization** - Next.js + Cloudinary
- **Code splitting** - Automatic via Next.js App Router
- **Bundle optimization** - Tree shaking and dead code elimination

### **Error Handling:**

- **Graceful degradation** - Fallbacks for failed operations
- **User-friendly messages** - Clear error communication
- **Logging** - Proper error tracking and debugging
- **Validation** - Input validation at all boundaries

## ğŸ“‹ Development Checklist

### **Before Starting Work:**

- [ ] Understand the full context and requirements
- [ ] Check existing patterns and implementations
- [ ] Plan the implementation approach
- [ ] Consider edge cases and error scenarios
- [ ] Ensure alignment with architecture

### **During Development:**

- [ ] Follow established patterns and conventions
- [ ] Write self-documenting code
- [ ] Implement comprehensive error handling
- [ ] Add proper TypeScript types
- [ ] Consider performance implications
- [ ] Test functionality thoroughly

### **Before Committing:**

- [ ] Code review against quality standards
- [ ] Ensure no redundant code or logic
- [ ] Verify error handling is comprehensive
- [ ] Check type safety and validation
- [ ] Confirm readability and maintainability
- [ ] Test edge cases and error scenarios

### **Git Workflow:**

- [ ] Create appropriate branch from `main`
- [ ] Write descriptive commit messages
- [ ] Make frequent, focused commits
- [ ] Open PR with detailed description
- [ ] Address review feedback
- [ ] Merge to `main` after approval

---

## ğŸ¯ Final Reminder

**ğŸš¨ MANDATORY FOR EVERY NEW CHAT:**

- **READ THIS DIRECTIVE FILE FIRST** - Always start by reading `.cursor-directives.md`
- **UNDERSTAND THE PROJECT** - Review architecture, patterns, and current status
- **FOLLOW ALL STANDARDS** - Adhere to quality, patterns, and conventions outlined above

**ULTRA-THINKING IS MANDATORY**: Every code change requires deep analysis, architectural consideration, and quality assurance. Take the time to understand the full system, prevent redundancy, and ensure maintainability. Quality over speed, always.

**ARCHITECTURE CONSISTENCY**: Follow established patterns, maintain clean separation of concerns, and ensure all changes fit seamlessly into the existing codebase architecture.

**CLEANLINESS & SIMPLICITY**: Write code that is self-documenting, easy to understand, and simple to maintain. Future developers should be able to understand and modify your code without extensive documentation.

---

## ğŸ“‹ Quick Reference Checklist for New Chats

**Before Starting Any Work:**

- [ ] Read `.cursor-directives.md` file completely
- [ ] Understand current branch status (`dev` branch active)
- [ ] Review project architecture and patterns
- [ ] Check for existing implementations before creating new ones
- [ ] Follow established service/hook/validation patterns
- [ ] Ensure all changes align with quality standards

**Remember:** This directive file is your single source of truth for this project!

---

## ğŸš¨ Troubleshooting & Common Issues

### **Database Connection Issues**

```typescript
// Check if Supabase client is properly configured
const supabase = await this.getClient();
const { data, error } = await supabase.from('test_table').select('*').limit(1);

if (error) {
  console.error('Database connection failed:', error);
  // Check environment variables and Supabase project status
}
```

### **Type Safety Issues**

```typescript
// Common type errors and solutions
// âŒ Wrong: Using any types
const data: any = await getData();

// âœ… Correct: Proper typing
const data: ServiceResponse<Entity[]> = await getData();
if (data.success && data.data) {
  // TypeScript knows data.data is Entity[]
}
```

### **Cache Invalidation Problems**

```typescript
// âŒ Wrong: Not invalidating related entities
queryClient.invalidateQueries({ queryKey: ['entities'] });

// âœ… Correct: Comprehensive invalidation
queryClient.invalidateQueries({ queryKey: entityKeys.all });
queryClient.invalidateQueries({ queryKey: ['related-entities'] });
queryClient.invalidateQueries({ queryKey: ['dependent-data'] });
```

### **Validation Schema Issues**

```typescript
// âŒ Wrong: Missing error messages
const schema = z.object({
  name: z.string().min(1)
});

// âœ… Correct: Descriptive error messages
const schema = z.object({
  name: z.string().min(1, { message: 'Name is required and cannot be empty.' })
});
```

### **Service Layer Errors**

```typescript
// âŒ Wrong: Generic error handling
catch (error) {
  return { success: false, error: 'Something went wrong' };
}

// âœ… Correct: Specific error handling
catch (err) {
  return this.formatError(err, `Failed to retrieve ${TABLE_NAME} data.`);
}
```

## ğŸ¯ Best Practices & Code Quality

### **Component Development**

```typescript
// âœ… Good: Thin, focused components
export function SchoolCard({ school }: { school: School }) {
  const { data: teams } = useSchoolTeams(school.id);

  return (
    <Card>
      <CardHeader>
        <CardTitle>{school.name}</CardTitle>
        <CardDescription>{school.abbreviation}</CardDescription>
      </CardHeader>
      <CardContent>
        <TeamsList teams={teams} />
      </CardContent>
    </Card>
  );
}

// âŒ Bad: Fat components with business logic
export function SchoolCard({ school }: { school: School }) {
  const [teams, setTeams] = useState([]);

  useEffect(() => {
    // Direct API calls in component
    fetch(`/api/schools/${school.id}/teams`)
      .then(res => res.json())
      .then(setTeams);
  }, [school.id]);

  // Complex business logic in component
  const calculateTeamStats = () => { /* ... */ };

  return (/* complex JSX */);
}
```

### **Hook Development**

```typescript
// âœ… Good: Proper error handling and loading states
export function useSchool(id: string) {
  return useQuery({
    queryKey: schoolKeys.details(id),
    queryFn: () => getSchoolById(id),
    enabled: !!id,
    select: (data) => {
      if (!data.success || !data.data) {
        throw new Error(data.error || 'School not found');
      }
      return data.data;
    },
    retry: 2,
    staleTime: 5 * 60 * 1000 // 5 minutes
  });
}

// âŒ Bad: Missing error handling
export function useSchool(id: string) {
  return useQuery({
    queryKey: ['school', id],
    queryFn: () => getSchoolById(id)
  });
}
```

### **Service Development**

```typescript
// âœ… Good: Comprehensive error handling and validation
static async insert(data: EntityInsert): Promise<ServiceResponse<undefined>> {
  try {
    // Validate required fields
    if (!data.name) {
      return { success: false, error: 'Name is required.' };
    }

    const supabase = await this.getClient();
    const { error } = await supabase.from(TABLE_NAME).insert(data);

    if (error) {
      // Handle specific database errors
      if (error.code === '23505') {
        return { success: false, error: 'Entity with this name already exists.' };
      }
      throw error;
    }

    return { success: true, data: undefined };
  } catch (err) {
    return this.formatError(err, `Failed to create ${TABLE_NAME} entity.`);
  }
}

// âŒ Bad: Minimal error handling
static async insert(data: EntityInsert) {
  const supabase = await this.getClient();
  const { error } = await supabase.from(TABLE_NAME).insert(data);
  return { success: !error, error };
}
```

### **Type Safety Best Practices**

```typescript
// âœ… Good: Comprehensive type definitions
export interface MatchWithFullDetails extends BaseEntity {
  id: number;
  name: string;
  sports_seasons_stages: {
    id: number;
    competition_stage: Database['public']['Enums']['competition_stage'];
    sports_categories: {
      id: number;
      division: Database['public']['Enums']['sport_divisions'];
      levels: Database['public']['Enums']['sport_levels'];
      sports: {
        id: number;
        name: string;
      };
    };
  };
  match_participants: {
    id: number;
    team_id: string;
    match_score: number | null;
    schools_teams: {
      id: string;
      name: string;
      schools: {
        name: string;
        abbreviation: string;
        logo_url: string | null;
      };
    };
  }[];
}

// âŒ Bad: Using any or loose types
export interface MatchWithFullDetails {
  id: any;
  name: string;
  details: any;
  participants: any[];
}
```

## ğŸ“Š Performance Optimization Guidelines

### **Query Optimization**

```typescript
// âœ… Good: Selective field queries
const { data } = await supabase
  .from('matches')
  .select('id, name, scheduled_at, status')
  .eq('status', 'upcoming');

// âŒ Bad: Selecting all fields
const { data } = await supabase.from('matches').select('*').eq('status', 'upcoming');
```

### **Cache Strategy**

```typescript
// âœ… Good: Appropriate cache times
export function useUpcomingMatches() {
  return useQuery({
    queryKey: matchKeys.upcoming,
    queryFn: getUpcomingMatches,
    staleTime: 2 * 60 * 1000, // 2 minutes for live data
    refetchInterval: 5 * 60 * 1000 // Refetch every 5 minutes
  });
}

export function useSchoolDetails(id: string) {
  return useQuery({
    queryKey: schoolKeys.details(id),
    queryFn: () => getSchoolById(id),
    staleTime: 30 * 60 * 1000 // 30 minutes for static data
  });
}
```

### **Component Optimization**

```typescript
// âœ… Good: Memoized components
export const SchoolCard = React.memo(({ school }: { school: School }) => {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{school.name}</CardTitle>
      </CardHeader>
    </Card>
  );
});

// âœ… Good: Memoized callbacks
export function SchoolList() {
  const handleSchoolSelect = useCallback((school: School) => {
    // Handle selection
  }, []);

  return (
    <div>
      {schools.map(school => (
        <SchoolCard
          key={school.id}
          school={school}
          onSelect={handleSchoolSelect}
        />
      ))}
    </div>
  );
}
```

## ğŸ” Code Review Checklist

### **Before Submitting PR:**

- [ ] All 5 layers implemented correctly
- [ ] Type safety maintained throughout
- [ ] Error handling comprehensive
- [ ] Cache invalidation strategy implemented
- [ ] Validation schemas with proper error messages
- [ ] No business logic in components
- [ ] Proper separation of concerns
- [ ] Performance considerations addressed
- [ ] Related entities updated if needed
- [ ] Tests written (when test framework is ready)

### **Architecture Compliance:**

- [ ] Follows BaseService pattern
- [ ] Uses query key factories
- [ ] Implements ServiceResponse<T> pattern
- [ ] Maintains feature-based file organization
- [ ] No layer skipping
- [ ] Proper data flow (Component â†’ Hook â†’ Action â†’ Service â†’ Database)

### **Quality Standards:**

- [ ] Self-documenting code
- [ ] Consistent naming conventions
- [ ] Proper TypeScript usage
- [ ] Error messages user-friendly
- [ ] Code follows established patterns
- [ ] No redundant implementations
